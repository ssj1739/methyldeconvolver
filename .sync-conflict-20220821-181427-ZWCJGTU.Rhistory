target <- omp$marker.gr$target[i]
upper.bound <- mu[target] + n.sigma * sigma[target]
lower.bound <- mu[target] - n.sigma * sigma[target]
y.mat[i,1] <- as.numeric(meth.frac < upper.bound & meth.frac > lower.bound)
y.mat[i,2] <- which(names(mu) == target)
}
# For all cell types, iterate through each cell type c
for(c in 1:length(psi.vec)){
if(psi.vec[c]!=0){
#P = dbinom(x = sum(r.vec), size = length(r.vec), prob = meth.frac[[c]])
# For each CpG site r.i in read r (represented in r.vec)
for(r.i in r.vec){
# Compute P from the beta function
P = beta(r.i + shape1[[c]], 1-r.i+shape2[[c]])/beta.f[[c]]
# Update the psi value for each cell type by multiplying by P
psi.vec[c] <- psi.vec[c] * P
}
psi.vec[c] <- psi.vec[c] * P
}
}
# Output updated psi value into psi.mat
psi.mat[i,] <- psi.vec
if(verbose)
pbapply::setpb(pb = pb, value = i)
}
i
mu
names(mu)
target
omp$marker.gr
omp$marker.gr$target
omp$marker.gr$target[i]
omp$marker.gr[i,]
i
omp$marker.gr
omp$overlaps
omp$marker.gr
length(omp$marker.gr)
omp$overlaps
omp$overlaps@to
omp$overlaps@to[i]
target <- omp$marker.gr$target[omp$overlaps@to[i]]
target
# Compute psi value for each read, and create new psi matrix
psi.mat <- matrix(nrow = length(omp$overlaps), ncol = length(reference$beta_celltype_fits))
# Compute y value, which will be used in weighting
y.mat <- matrix(nrow = length(omp$overlaps), ncol = 2, dimnames = list(c(), c("y", "target.ind")))
colnames(psi.mat) <- names(reference$beta_celltype_fits)
if(verbose)
pb <- pbapply::startpb(min = 0, max = length(omp$overlaps))
for(i in 1:length(omp$overlaps)){
# Calculate r
r.vec = encode_binary(omp$pat.gr$read[omp$overlaps@from[i]])
# Extract shape1, shape2, and beta.f for each marker that's associated with the ith read
# Length of each of these vectors is the # of cell types
shape1 = sapply(reference$beta_celltype_fits, function(x) return(x$shape1[x$marker.index==omp$overlaps@to[i]]))
shape2 = sapply(reference$beta_celltype_fits, function(x) return(x$shape2[x$marker.index==omp$overlaps@to[i]]))
beta.f = sapply(reference$beta_celltype_fits, function(x) return(x$beta.f[x$marker.index==omp$overlaps@to[i]]))
psi.vec = unlist(sapply(reference$beta_celltype_fits, function(x) return(x$psi.init[x$marker.index==omp$overlaps@to[i]])))
meth.frac = sum(r.vec) / length(r.vec)
# Compute weights and populate y.mat
mu = sigma = NA
if(apply_weighting){
mu = sapply(reference$beta_celltype_fits, function(x) return(x$mu[x$marker.index==omp$overlaps@to[i]]))
sigma = sapply(reference$beta_celltype_fits, function(x) return(x$sigma[x$marker.index==omp$overlaps@to[i]]))
n.sigma = 3 ## TODO: PARAMETERIZE THIS
target <- omp$marker.gr$target[omp$overlaps@to[i]]
upper.bound <- mu[target] + n.sigma * sigma[target]
lower.bound <- mu[target] - n.sigma * sigma[target]
y.mat[i,1] <- as.numeric(meth.frac < upper.bound & meth.frac > lower.bound)
y.mat[i,2] <- which(names(mu) == target)
}
# For all cell types, iterate through each cell type c
for(c in 1:length(psi.vec)){
if(psi.vec[c]!=0){
#P = dbinom(x = sum(r.vec), size = length(r.vec), prob = meth.frac[[c]])
# For each CpG site r.i in read r (represented in r.vec)
for(r.i in r.vec){
# Compute P from the beta function
P = beta(r.i + shape1[[c]], 1-r.i+shape2[[c]])/beta.f[[c]]
# Update the psi value for each cell type by multiplying by P
psi.vec[c] <- psi.vec[c] * P
}
psi.vec[c] <- psi.vec[c] * P
}
}
# Output updated psi value into psi.mat
psi.mat[i,] <- psi.vec
if(verbose)
pbapply::setpb(pb = pb, value = i)
}
if(verbose)
on.exit(closepb(pb))
y.mat
### Set different random uniform priors based on the number of initializations specified by user
num_celltypes <- length(unique(reference$marker$target))
alpha.inits <- lapply(1:num_of_inits, function(x){
alpha <- runif(num_celltypes)
alpha  <- unlist(lapply(alpha, function(x) x/sum(alpha) )) # Normalize priors to 1
return(alpha)
})
# Set first prior to uniform prior
alpha.inits[[1]] <- rep(1, num_celltypes) / num_celltypes
alpha.inits
# Compute y value, which will be used in weighting
#y.mat <- matrix(nrow = length(omp$overlaps), ncol = 2, dimnames = list(c(), c("y", "target.ind")))
y.mat <- data.frame(y = numeric(length(omp$overlaps)), target = character(length(omp$overlaps)))
if(verbose) message("Computing psi matrix...")
# Compute psi value for each read, and create new psi matrix
psi.mat <- matrix(nrow = length(omp$overlaps), ncol = length(reference$beta_celltype_fits))
# Compute y value, which will be used in weighting
#y.mat <- matrix(nrow = length(omp$overlaps), ncol = 2, dimnames = list(c(), c("y", "target.ind")))
y.mat <- data.frame(y = numeric(length(omp$overlaps)), target = character(length(omp$overlaps)))
# Compute psi value for each read, and create new psi matrix
psi.mat <- matrix(nrow = length(omp$overlaps), ncol = length(reference$beta_celltype_fits), dimnames = list(c(), names(reference$beta_celltype_fits)))
psi.mat
colnames(psi.mat)
# Compute psi value for each read, and create new psi matrix
psi.mat <- matrix(nrow = length(omp$overlaps), ncol = length(reference$beta_celltype_fits), dimnames = list(c(), names(reference$beta_celltype_fits)))
# Compute y value, which will be used in weighting
#y.mat <- matrix(nrow = length(omp$overlaps), ncol = 2, dimnames = list(c(), c("y", "target.ind")))
y.mat <- data.frame(y = numeric(length(omp$overlaps)), target = character(length(omp$overlaps)))
if(verbose)
pb <- pbapply::startpb(min = 0, max = length(omp$overlaps))
for(i in 1:length(omp$overlaps)){
# Calculate r
r.vec = encode_binary(omp$pat.gr$read[omp$overlaps@from[i]])
# Extract shape1, shape2, and beta.f for each marker that's associated with the ith read
# Length of each of these vectors is the # of cell types
shape1 = sapply(reference$beta_celltype_fits, function(x) return(x$shape1[x$marker.index==omp$overlaps@to[i]]))
shape2 = sapply(reference$beta_celltype_fits, function(x) return(x$shape2[x$marker.index==omp$overlaps@to[i]]))
beta.f = sapply(reference$beta_celltype_fits, function(x) return(x$beta.f[x$marker.index==omp$overlaps@to[i]]))
psi.vec = unlist(sapply(reference$beta_celltype_fits, function(x) return(x$psi.init[x$marker.index==omp$overlaps@to[i]])))
meth.frac = sum(r.vec) / length(r.vec)
# Compute weights and populate y.mat
mu = sigma = NA
if(apply_weighting){
mu = sapply(reference$beta_celltype_fits, function(x) return(x$mu[x$marker.index==omp$overlaps@to[i]]))
sigma = sapply(reference$beta_celltype_fits, function(x) return(x$sigma[x$marker.index==omp$overlaps@to[i]]))
n.sigma = 3 ## TODO: PARAMETERIZE THIS
target <- omp$marker.gr$target[omp$overlaps@to[i]]
upper.bound <- mu[target] + n.sigma * sigma[target]
lower.bound <- mu[target] - n.sigma * sigma[target]
y.mat$y[i] <- as.numeric(meth.frac < upper.bound & meth.frac > lower.bound)
y.mat$target[i] <- target
#y.mat[i,1] <- as.numeric(meth.frac < upper.bound & meth.frac > lower.bound)
#y.mat[i,2] <- which(names(mu) == target)
}
# For all cell types, iterate through each cell type c
for(c in 1:length(psi.vec)){
if(psi.vec[c]!=0){
#P = dbinom(x = sum(r.vec), size = length(r.vec), prob = meth.frac[[c]])
# For each CpG site r.i in read r (represented in r.vec)
for(r.i in r.vec){
# Compute P from the beta function
P = beta(r.i + shape1[[c]], 1-r.i+shape2[[c]])/beta.f[[c]]
# Update the psi value for each cell type by multiplying by P
psi.vec[c] <- psi.vec[c] * P
}
psi.vec[c] <- psi.vec[c] * P
}
}
# Output updated psi value into psi.mat
psi.mat[i,] <- psi.vec
if(verbose)
pbapply::setpb(pb = pb, value = i)
}
if(verbose)
on.exit(closepb(pb))
if(verbose) message("Performing EM")
### Set different random uniform priors based on the number of initializations specified by user
num_celltypes <- length(unique(reference$marker$target))
alpha.inits <- lapply(1:num_of_inits, function(x){
alpha <- runif(num_celltypes)
alpha  <- unlist(lapply(alpha, function(x) x/sum(alpha) )) # Normalize priors to 1
return(alpha)
})
# Set first prior to uniform prior
alpha.inits[[1]] <- rep(1, num_celltypes) / num_celltypes
alpha.inits
alpha = alpha.inits[[1]]
i.iter = 1
if(max_iter <= i.iter){
stop("Number of maximum iterations must be greater than 1")
}
mad = vector()
mad[1] <- 1
all.alphas <- list()
all.alphas[[i.iter]] <- alpha
tol = 1e-3
# Save old alpha
alpha.old = alpha
# Calculate new phi
learn.zeta.mat <- data.frame(y = y.mat[,1], alpha = alpha.old[y.mat[,2]])
learn.zeta.mat
y.mat
hist(y.mat[,1])
y.mat
summary(y.mat[,1])
learn.zeta.mat
alpha.old
# Compute psi value for each read, and create new psi matrix
psi.mat <- matrix(nrow = length(omp$overlaps), ncol = length(reference$beta_celltype_fits), dimnames = list(c(), names(reference$beta_celltype_fits)))
# Compute y value, which will be used in weighting
y.mat <- matrix(nrow = length(omp$overlaps), ncol = 2, dimnames = list(c(), c("y", "target.ind")))
if(verbose)
pb <- pbapply::startpb(min = 0, max = length(omp$overlaps))
for(i in 1:length(omp$overlaps)){
# Calculate r
r.vec = encode_binary(omp$pat.gr$read[omp$overlaps@from[i]])
# Extract shape1, shape2, and beta.f for each marker that's associated with the ith read
# Length of each of these vectors is the # of cell types
shape1 = sapply(reference$beta_celltype_fits, function(x) return(x$shape1[x$marker.index==omp$overlaps@to[i]]))
shape2 = sapply(reference$beta_celltype_fits, function(x) return(x$shape2[x$marker.index==omp$overlaps@to[i]]))
beta.f = sapply(reference$beta_celltype_fits, function(x) return(x$beta.f[x$marker.index==omp$overlaps@to[i]]))
psi.vec = unlist(sapply(reference$beta_celltype_fits, function(x) return(x$psi.init[x$marker.index==omp$overlaps@to[i]])))
meth.frac = sum(r.vec) / length(r.vec)
# Compute weights and populate y.mat
mu = sigma = NA
if(apply_weighting){
mu = sapply(reference$beta_celltype_fits, function(x) return(x$mu[x$marker.index==omp$overlaps@to[i]]))
sigma = sapply(reference$beta_celltype_fits, function(x) return(x$sigma[x$marker.index==omp$overlaps@to[i]]))
n.sigma = 3 ## TODO: PARAMETERIZE THIS
target <- omp$marker.gr$target[omp$overlaps@to[i]]
upper.bound <- mu[target] + n.sigma * sigma[target]
lower.bound <- mu[target] - n.sigma * sigma[target]
#y.mat$y[i] <- as.numeric(meth.frac < upper.bound & meth.frac > lower.bound)
#y.mat$target[i] <- target
#y.mat[i,1] <- as.numeric(meth.frac < upper.bound & meth.frac > lower.bound)
#y.mat[i,2] <- which(names(mu) == target)
}
# For all cell types, iterate through each cell type c
for(c in 1:length(psi.vec)){
if(psi.vec[c]!=0){
#P = dbinom(x = sum(r.vec), size = length(r.vec), prob = meth.frac[[c]])
# For each CpG site r.i in read r (represented in r.vec)
for(r.i in r.vec){
# Compute P from the beta function
P = beta(r.i + shape1[[c]], 1-r.i+shape2[[c]])/beta.f[[c]]
# Update the psi value for each cell type by multiplying by P
psi.vec[c] <- psi.vec[c] * P
}
psi.vec[c] <- psi.vec[c] * P
}
}
# Output updated psi value into psi.mat
psi.mat[i,] <- psi.vec
if(verbose)
pbapply::setpb(pb = pb, value = i)
}
if(verbose)
on.exit(closepb(pb))
if(verbose) message("Performing EM")
### Set different random uniform priors based on the number of initializations specified by user
num_celltypes <- length(unique(reference$marker$target))
alpha.inits <- lapply(1:num_of_inits, function(x){
alpha <- runif(num_celltypes)
alpha  <- unlist(lapply(alpha, function(x) x/sum(alpha) )) # Normalize priors to 1
return(alpha)
})
# Set first prior to uniform prior
alpha.inits[[1]] <- rep(1, num_celltypes) / num_celltypes
alpha.inits
names(reference$beta_celltype_fits)
### Set different random uniform priors based on the number of initializations specified by user
num_celltypes <- length(unique(reference$marker$target))
alpha.inits <- lapply(1:num_of_inits, function(x){
alpha <- runif(num_celltypes)
alpha  <- unlist(lapply(alpha, function(x) x/sum(alpha) )) # Normalize priors to 1
names(alpha) <- names(reference$beta_celltype_fits)
return(alpha)
})
# Set first prior to uniform prior
alpha.inits[[1]] <- rep(1, num_celltypes) / num_celltypes
alpha.inits
rm(alpha.inits)
# Set first prior to uniform prior
alpha.inits[[1]] <- rep(1, num_celltypes) / num_celltypes
### Set different random uniform priors based on the number of initializations specified by user
num_celltypes <- length(unique(reference$marker$target))
# Set first prior to uniform prior
alpha.inits <- lapply(1:(num_of_inits+1), function(x){
alpha <- runif(num_celltypes)
alpha  <- unlist(lapply(alpha, function(x) x/sum(alpha) )) # Normalize priors to 1
names(alpha) <- names(reference$beta_celltype_fits)
return(alpha)
})
names(alpha.inits[[1]]) <- names(reference$beta_celltype_fits)
alpha.inits
### Set different random uniform priors based on the number of initializations specified by user
num_celltypes <- length(unique(reference$marker$target))
# Set first prior to uniform prior
alpha.inits <- lapply(1:(num_of_inits+1), function(x){
alpha <- runif(num_celltypes)
alpha  <- unlist(lapply(alpha, function(x) x/sum(alpha) )) # Normalize priors to 1
names(alpha) <- names(reference$beta_celltype_fits)
return(alpha)
})
alpha.inits[[1]] <- rep(1, num_celltypes) / num_celltypes
names(alpha.inits[[1]]) <- names(reference$beta_celltype_fits)
alpha.inits
alpha = alpha.inits[[1]]
y.mat
# Compute y value, which will be used in weighting
y.mat <- matrix(nrow = length(omp$overlaps), ncol = 2, dimnames = list(c(), c("y", "target.ind")))
# Compute y value, which will be used in weighting
y.mat <- matrix(nrow = length(omp$overlaps), ncol = 2, dimnames = list(c(), c("y", "target.ind")))
if(verbose)
pb <- pbapply::startpb(min = 0, max = length(omp$overlaps))
for(i in 1:length(omp$overlaps)){
# Calculate r
r.vec = encode_binary(omp$pat.gr$read[omp$overlaps@from[i]])
# Extract shape1, shape2, and beta.f for each marker that's associated with the ith read
# Length of each of these vectors is the # of cell types
shape1 = sapply(reference$beta_celltype_fits, function(x) return(x$shape1[x$marker.index==omp$overlaps@to[i]]))
shape2 = sapply(reference$beta_celltype_fits, function(x) return(x$shape2[x$marker.index==omp$overlaps@to[i]]))
beta.f = sapply(reference$beta_celltype_fits, function(x) return(x$beta.f[x$marker.index==omp$overlaps@to[i]]))
psi.vec = unlist(sapply(reference$beta_celltype_fits, function(x) return(x$psi.init[x$marker.index==omp$overlaps@to[i]])))
meth.frac = sum(r.vec) / length(r.vec)
# Compute weights and populate y.mat
mu = sigma = NA
if(apply_weighting){
mu = sapply(reference$beta_celltype_fits, function(x) return(x$mu[x$marker.index==omp$overlaps@to[i]]))
sigma = sapply(reference$beta_celltype_fits, function(x) return(x$sigma[x$marker.index==omp$overlaps@to[i]]))
n.sigma = 3 ## TODO: PARAMETERIZE THIS
target <- omp$marker.gr$target[omp$overlaps@to[i]]
upper.bound <- mu[target] + n.sigma * sigma[target]
lower.bound <- mu[target] - n.sigma * sigma[target]
#y.mat$y[i] <- as.numeric(meth.frac < upper.bound & meth.frac > lower.bound)
#y.mat$target[i] <- target
y.mat[i,1] <- as.numeric(meth.frac < upper.bound & meth.frac > lower.bound)
y.mat[i,2] <- which(names(mu) == target)
}
# For all cell types, iterate through each cell type c
for(c in 1:length(psi.vec)){
if(psi.vec[c]!=0){
#P = dbinom(x = sum(r.vec), size = length(r.vec), prob = meth.frac[[c]])
# For each CpG site r.i in read r (represented in r.vec)
for(r.i in r.vec){
# Compute P from the beta function
P = beta(r.i + shape1[[c]], 1-r.i+shape2[[c]])/beta.f[[c]]
# Update the psi value for each cell type by multiplying by P
psi.vec[c] <- psi.vec[c] * P
}
psi.vec[c] <- psi.vec[c] * P
}
}
# Output updated psi value into psi.mat
psi.mat[i,] <- psi.vec
if(verbose)
pbapply::setpb(pb = pb, value = i)
}
if(verbose)
on.exit(closepb(pb))
if(verbose) message("Performing EM")
### Set different random uniform priors based on the number of initializations specified by user
num_celltypes <- length(unique(reference$marker$target))
# Set first prior to uniform prior
alpha.inits <- lapply(1:(num_of_inits+1), function(x){
alpha <- runif(num_celltypes)
alpha  <- unlist(lapply(alpha, function(x) x/sum(alpha) )) # Normalize priors to 1
names(alpha) <- names(reference$beta_celltype_fits)
return(alpha)
})
alpha.inits[[1]] <- rep(1, num_celltypes) / num_celltypes
names(alpha.inits[[1]]) <- names(reference$beta_celltype_fits)
y.mat
alpha
i.iter = 1
if(max_iter <= i.iter){
stop("Number of maximum iterations must be greater than 1")
}
mad = vector()
mad[1] <- 1
all.alphas <- list()
all.alphas[[i.iter]] <- alpha
tol = 1e-3
# Save old alpha
alpha.old = alpha
# Calculate new phi
learn.zeta.mat <- data.frame(y = y.mat[,1], alpha = alpha.old[y.mat[,2]])
learn.zeta.mat
zeta.fit <- glm(y ~ alpha, data = learn.zeta.mat, family="binomial")
zeta.fit
omega.vec <- predict(zeta.fit, newdata = data.frame(alpha = alpha), type = "response")
omega.vec
devtools::check()
devtools::install()
# Full test
library(methyldeconvolveR)
ref <- learn_reference(marker.file = "data/FullTest/Sid_testmarkers.bed", pat.dir = "data/FullTest/ref/", save.output = "data/FullTest/FullTest_ref.rds")
#ref <- readRDS("data/FullTest/FullTest_ref.rds")
sample.pat <- read_pat(path = "data/FullTest/test_mix_1.pat.gz")
true_distr <- rep(sample.pat$V5, times = sample.pat$nobs)
cell_types <- unique(sample.pat$V5)
count_distr <- numeric(5)
names(count_distr) <- cell_types
for(i in 1:length(cell_types)){
print(paste0("Completing ", cell_types[i]))
count_distr[i] <- sum(true_distr == cell_types[i])
}
true_prop <- count_distr / sum(count_distr)
print(true_prop)
res <- deconvolute_sample(sample.pat.path = "data/FullTest/test_mix_1.pat.gz", reference = ref, verbose = T, n_threads = 6)
res_unweighted <- res
res_weighted <- deconvolute_sample(sample.pat.path = "data/FullTest/test_mix_1.pat.gz", apply_weights = T, reference = ref, verbose = T, n_threads = 6)
res_weighted <- deconvolute_sample(sample.pat.path = "data/FullTest/test_mix_1.pat.gz", apply_weighting = T, reference = ref, verbose = T, n_threads = 6)
res_weighted
true_prop
true_prop[sort(names(true_prop))]
true_prop
true_prop <- count_distr / sum(count_distr)
true_prop <- true_prop[sort(names(true_prop))]
print(true_prop)
res_unweighted
res_weighted
devtools::install()
reference <- readRDS("data/FullTest/FullTest_ref.rds")
reference
reference$beta_celltype_fits$bcell_merged
sample.pat.path = "data/FullTest/test_mix_1.pat.gz"
apply_weighting = T
#ref <- learn_reference(marker.file = "data/FullTest/Sid_testmarkers.bed", pat.dir = "data/FullTest/ref/", save.output = "data/FullTest/FullTest_ref.rds")
ref <- readRDS("data/FullTest/FullTest_ref.rds")
sample.pat <- read_pat(path = "data/FullTest/test_mix_1.pat.gz")
true_distr <- rep(sample.pat$V5, times = sample.pat$nobs)
cell_types <- unique(sample.pat$V5)
count_distr <- numeric(5)
names(count_distr) <- cell_types
for(i in 1:length(cell_types)){
print(paste0("Completing ", cell_types[i]))
count_distr[i] <- sum(true_distr == cell_types[i])
}
true_prop <- count_distr / sum(count_distr)
true_prop <- true_prop[sort(names(true_prop))]
print(true_prop)
res_unweighted <- deconvolute_sample(sample.pat.path = "data/FullTest/test_mix_1.pat.gz", apply_weighting = F, reference = ref, verbose = T, n_threads = 6)
res_weighted <- deconvolute_sample(sample.pat.path = "data/FullTest/test_mix_1.pat.gz", apply_weighting = T, reference = ref, verbose = T, n_threads = 6)
sample.pat$V5
View(sample.pat)
View(head(sample.pat))
true_prop
lapply(res_unweighted, function(x){
caret::RMSE(x$last_alpha, true_prop[names(x$last_alpha)])
})
lapply(res_weighted, function(x){
caret::RMSE(x$last_alpha, true_prop[names(x$last_alpha)])
})
true_prop
res_unweighted[[1]]$last_alpha
res_weighted[[1]]$last_alpha
devtools::build()
devtools::build()
devtools::build()
devtools::build()
# Full test
library(methyldeconvolveR)
ref <- learn_reference(marker.file = "data/FullTest/Sid_testmarkers.bed", pat.dir = "data/FullTest/ref/", save.output = "data/FullTest/FullTest_ref.rds")
#ref <- readRDS("data/FullTest/FullTest_ref.rds")
sample.pat <- read_pat(path = "data/FullTest/test_mix_1.pat.gz", verbose = T)
true_distr <- rep(sample.pat$V5, times = sample.pat$nobs)
cell_types <- unique(sample.pat$V5)
count_distr <- numeric(5)
names(count_distr) <- cell_types
for(i in 1:length(cell_types)){
print(paste0("Completing ", cell_types[i]))
count_distr[i] <- sum(true_distr == cell_types[i])
}
true_prop <- count_distr / sum(count_distr)
true_prop <- true_prop[sort(names(true_prop))]
print(true_prop)
res_unweighted <- deconvolute_sample(sample.pat.path = "data/FullTest/test_mix_1.pat.gz", apply_weighting = F, reference = ref, verbose = T, n_threads = 6)
res_weighted <- deconvolute_sample(sample.pat.path = "data/FullTest/test_mix_1.pat.gz", apply_weighting = T, reference = ref, verbose = T, n_threads = 6)
lapply(res_unweighted, function(x){
caret::RMSE(x$last_alpha, true_prop[names(x$last_alpha)])
})
lapply(res_weighted, function(x){
caret::RMSE(x$last_alpha, true_prop[names(x$last_alpha)])
})
# Visualize results
res_df <- data.frame(
cell_types = names(true_prop),
truth = true_prop,
unweighted = res_unweighted[[1]]$last_alpha,
weighted = res_weighted[[1]]$last_alpha
)
res_df_clean <- res_df %>%
tidyr::pivot_longer(cols = -cell_types, names_to = "Estimate", values_to = "Proportions")
ggplot(res_df_clean, aes(x = cell_types, y = Proportions, color = Estimate)) +
geom_point()
library(tidyverse)
ggplot(res_df_clean, aes(x = cell_types, y = Proportions, color = Estimate)) +
geom_point()
ggplot(res_df_clean, aes(x = cell_types, y = Proportions, color = Estimate)) +
geom_boxplot()
x
res_unweighted
lapply(res_unweighted, function(x){
return(x$last_alpha)
}) %>% bind_rows()
iter_df <- lapply(res_unweighted, function(x){
return(x$last_alpha)
}) %>% bind_rows()
colMeans(iter_df)
apply(iter_df, 2, var)
iter_df <- lapply(res_weighted, function(x){
return(x$last_alpha)
}) %>% bind_rows()
colMeans(iter_df)
apply(iter_df, 2, var)
ggsave(filename = "figs/MixIn_WeightedvsUnweighted.png", width = 6, height = 5, dpi = 300)
ggsave(filename = "figs/MixIn_WeightedvsUnweighted.png", width = 8, height = 5, dpi = 300)
